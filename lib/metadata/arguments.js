// cmd-tokenize <https://github.com/msikma/cmd-tokenize>
// © MIT license

const { mergeDefaults } = require('../defaults')

/**
 * Returns whether a given argument is the terminator or not.
 */
const findTerminator = (arg, options, format, isExec = false, isAfterTerminator = false) => {
  if (isExec || isAfterTerminator || !options.useOptionsTerminator) return false
  if (arg === format.optionsTerminator) return true
  if (isAfterTerminator === null) return null // TODO: add to tests
  return false
}

/**
 * Returns data about any suffix that might be part of this option.
 * 
 * This takes the result of findPrefix(), as only options can have a suffix.
 */
const findSuffix = (prefix, suffixes, isStatic = false) => {
  let suffix = null
  let content = prefix.remainder
  let pairedValue = null

  if (!isStatic && prefix.metadata.isOption) {
    for (const suffixItem of suffixes) {
      const matches = prefix.remainder.match(suffixItem.re)
      if (matches == null) {
        continue
      }
      content = matches[1]
      suffix = matches[2]
      pairedValue = matches[3]
      break
    }
  }

  return {
    metadata: { suffix },
    content,
    pairedValue
  }
}

/**
 * Returns data about any prefix that might be part of this argument.
 */
const findPrefix = (arg, prefixes, isStatic = false) => {
  let prefix = null
  let isLongOption = false
  let isOption = false
  let remainder = arg

  if (!isStatic) {
    for (const prefixItem of prefixes) {
      const matches = arg.match(prefixItem.re)
      if (matches == null || matches[2] === '') {
        continue
      }
      prefix = matches[1]
      isLongOption = prefix.length > 1
      isOption = true
      remainder = matches[2]
      break
    }
  }

  return {
    metadata: { prefix, isLongOption, isOption },
    remainder
  }
}


/**
 * Checks whether an argument is a combined option, e.g. "-ab" being a combination of "-a" and "-b".
 */
const isCombinedOption = (content, prefix, options, isStatic) => {
  if (!options.unpackCombinedOptions) {
    return false
  }
  return !isStatic && prefix.metadata.isOption && !prefix.metadata.isLongOption && content.length > 1
}

/**
 * Unpacks an argument if it is a combined argument, and returns them in an array,
 * or returns only the original argument itself wrapped in an array.
 */
const unpackCombinedOptions = (argObject, needsUnpacking) => {
  // In most cases, arguments will not be combined options.
  if (!needsUnpacking) {
    return [{ ...argObject, isUnpacked: false }]
  }

  // Unpack combined options into multiple items.
  // E.g. the original might be "ab", in which case we get two items "a" and "b".
  const items = []
  for (let n = 0; n < argObject.content.length; ++n) {
    const char = argObject.content[n]
    const isLast = n === argObject.content.length - 1

    // Ensure that pairing is off for all except the last item. This is to ensure that,
    // if an argument like -asdf="a" is passed, only the -f argument is paired and not the rest.
    const isPaired = isLast && argObject.isPaired

    items.push({ ...argObject, isPaired, content: char, isUnpacked: true })
  }
  return items
}

/**
 * Adds a paired value to a list of arguments generated by argumentMetadata().
 * 
 * This is done for arguments like --foo="bar", where --foo needs to be marked
 * as being paired with "bar", which is a separate argument item.
 */
const addPairedValue = (argsList, suffix) => {
  // Note: a pairedValue can be an empty string.
  if (suffix.pairedValue == null) {
    return argsList
  }

  // Note: if a suffix pairedValue exists, this argument can by definition not be
  // the executable, or the terminator, or after the terminator.
  // The argument that the item is paired with can only be the last item.
  const sourceArgObject = argsList.slice(-1)[0]

  return [
    ...argsList.slice(0, -1),
    {
      ...sourceArgObject,
      isKey: true
    },
    {
      ...sourceArgObject,
      content: suffix.pairedValue,
      prefix: null,
      suffix: null,
      isOption: false,
      isLongOption: false,
      isKey: false,
      isValue: true,
      isUnpacked: false
    }
  ]
}

/**
 * An entry point for argumentMetadata() that can be called directly.
 * 
 * The rest of the code does not call this function, so the defaults get merged into
 * the user's options and format here too. It's exposed to the user as 'argumentMetadata()'.
 */
const argumentMetadataStandalone = (arg, userOptions, userFormat, isExec = null, isAfterTerminator = null) => {
  const { options, format } = mergeDefaults(userOptions, userFormat)
  return argumentMetadata(arg, options, format, isExec, isAfterTerminator)
}

/**
 * Converts an argument string into an object that has more extensive information.
 */
const argumentMetadata = (arg, options, format, isExec, isAfterTerminator) => {
  // Check if this is the terminator argument that ends options processing.
  const isTerminator = findTerminator(arg, options, format, isExec, isAfterTerminator)

  // An argument can only be static (i.e. not an option) after the terminator.
  // The initial argument (the executable path) can also not be an option.
  const isStatic = isTerminator || isAfterTerminator || isExec

  // The prefix is present for all options, e.g. --my-option.
  const prefix = findPrefix(arg, format.valuePrefix, isStatic)

  // A suffix indicates that this item is paired with a value.
  // E.g. for --foo="bar", "foo" is paired with "bar", and both are separate objects.
  // The paired argument object is added just before returning.
  const suffix = findSuffix(prefix, format.valueSuffix, isStatic)

  // Each argument has the following metadata.
  const argObject = {
    content: suffix.content,
    ...prefix.metadata,
    ...suffix.metadata,
    isKey: false,
    isValue: false,
    isTerminator,
    isExecutable: isExec,
    isAfterTerminator,
    isUnpacked: null,  // set below
    originalValue: arg
  }

  // Unix style options can be combined, e.g. "-ab" meaning two options named "-a" and "-b".
  // At the same time, some programs (like ffmpeg) do not use combined options, and "-ab"
  // simply means one option named "ab". We parse these either way.
  // Arguments are returned as an array; either with a single item, or with multiple items
  // if the argument is a combined one.
  const argsList = unpackCombinedOptions(argObject, isCombinedOption(argObject.content, prefix, options, isStatic))

  // Add any paired value that might have been detected earlier.
  return addPairedValue(argsList, suffix)
}


module.exports = {
  argumentMetadata,
  argumentMetadataStandalone,
  findPrefix,
  findSuffix,
  findTerminator
}
